# 補正モデルの実装と理論的背景

## 0. 使用ライブラリ

```python
import numpy as np              # 数値計算基礎ライブラリ
import pandas as pd            # データ処理ライブラリ
from scipy.interpolate import RBFInterpolator  # Radial Basis Function補間
import pickle                  # モデルの保存・読み込み
from pathlib import Path       # パス操作
from scipy import stats       # 統計処理
import matplotlib.pyplot as plt # 可視化
from matplotlib.colors import LinearSegmentedColormap  # カラーマップ作成
```

主要ライブラリの役割：
- numpy: 数値計算全般、特に配列操作と数学関数
- pandas: データフレーム操作、グループ化処理
- scipy.interpolate: RBF補間の実装
- matplotlib: 結果の可視化、プロット生成

## 1. 補正モデルの概要

### 1.1 基本アプローチ
補正モデルは、測定された位置ずれデータを基に、任意の位置での補正量を予測する仕組みを提供します。主な特徴は：

- 区画分割による局所的な特性の捕捉
- Radial Basis Function (RBF) による補間
- スケーラブルな分割数の設定
- 外周部の特別処理

### 1.2 実装における重要なクラスと関数

```python
class DataAnalyzer:
    def create_correction_model(self, x_divisions, y_divisions, interpolate_all=False):
        # モデル生成の主要メソッド
```

## 2. 実装の詳細

### 2.1 区画分割プロセス

#### 2.1.1 分割パラメータの詳細

コマンドライン引数：
```python
parser.add_argument("--x_divisions", type=int, default=10,
                   help="Number of X divisions")
parser.add_argument("--y_divisions", type=int, default=10,
                   help="Number of Y divisions")
```

パラメータの意味：
- `x_divisions`: X方向の分割数
  - デフォルト値: 10
  - 推奨範囲: 5-20
  - 値を大きくすると：
    - より細かい局所的な変動を捉えられる
    - 計算コストが増加
    - オーバーフィッティングのリスクが増加

- `y_divisions`: Y方向の分割数
  - デフォルト値: 10
  - 推奨範囲: 5-20
  - x_divisionsと同様の特性

選定の指針：
1. データ点の密度に応じて調整
   - 点が密集：より多くの分割
   - 点が疎：より少ない分割
2. 位置ずれの空間的変動の大きさを考慮
3. 計算時間とのトレードオフを検討

```python
# エッジの生成
x_min, x_max = data['target_x'].min(), data['target_x'].max()
y_min, y_max = data['target_y'].min(), data['target_y'].max()

# 基本の区画分割
x_edges = np.linspace(x_min, x_max, x_divisions + 1)
y_edges = np.linspace(y_min, y_max, y_divisions + 1)

# 外周部の詳細分割
x_outer_left = np.linspace(x_min, x_edges[1], 3)
x_outer_right = np.linspace(x_edges[-2], x_max, 3)
y_outer_bottom = np.linspace(y_min, y_edges[1], 3)
y_outer_top = np.linspace(y_edges[-2], y_max, 3)
```

この実装の特徴：
- 外周部は他の区画より細かく分割
- エッジ部分での補間精度を向上
- 不連続性を防ぐための重複領域の確保

### 2.2 補間処理の実装

#### 2.2.1 全ポイント補間モード
```python
if interpolate_all:
    points = data[['target_x', 'target_y']].values
    values = data[['X_DIS_Target', 'Y_DIS_Target']].values
    rbf_x = RBFInterpolator(points, -values[:, 0])
    rbf_y = RBFInterpolator(points, -values[:, 1])
```

#### 2.2.2 区画平均補間モード
```python
grouped = data.groupby([
    pd.cut(data['target_x'], x_edges_refined),
    pd.cut(data['target_y'], y_edges_refined)
], observed=True)
avg_data = grouped[['target_x', 'target_y', 'X_DIS_Target', 'Y_DIS_Target']].mean()
```

## 3. 理論的背景

### 3.1 RBF補間の理論

Radial Basis Function補間は以下の特徴を持ちます：

1. 数学的基礎
   - 距離に基づく重み付け
   - スムーズな補間曲面の生成
   - 局所的な変動の捕捉能力

2. 補間関数の形式
   ```
   f(x) = Σ(wi * φ(||x - xi||))
   ```
   - φ: 基底関数
   - wi: 重み係数
   - xi: データ点
   - ||x - xi||: ユークリッド距離

### 3.2 区画分割の理論的根拠

1. 局所性の確保
   - 位置ずれの局所的な特性を保持
   - オーバーフィッティングの抑制
   - 計算効率の向上

2. 外周部特別処理の必要性
   - エッジ効果の補正
   - 境界条件の適切な処理
   - 補間精度の向上

## 4. 実装上の重要な考慮点

### 4.1 データの前処理

```python
# 異常値の除去と基準化
data_cleaned = data.copy()
data_cleaned.dropna(inplace=True)
```

### 4.2 補正モデルの適用

```python
@staticmethod
def apply_correction(x, y, rbf_x, rbf_y):
    points = np.column_stack((x, y))
    corr_x = rbf_x(points)
    corr_y = rbf_y(points)
    return x + corr_x, y + corr_y
```

### 4.3 モデルの保存と再利用

#### 4.3.1 モデルの保存
```python
# モデルの保存
with open(output_pkl, 'wb') as f:
    pickle.dump((rbf_x, rbf_y), f)
```

#### 4.3.2 モデルの読み込みと適用例
```python
# モデルの読み込み
import pickle
import numpy as np
from scipy.interpolate import RBFInterpolator

def load_correction_model(model_path):
    with open(model_path, 'rb') as f:
        rbf_x, rbf_y = pickle.load(f)
    return rbf_x, rbf_y

def apply_correction_to_data(x_original, y_original, model_path):
    """
    補正モデルを適用して座標を補正する

    Parameters:
    -----------
    x_original : array-like
        補正前のX座標
    y_original : array-like
        補正前のY座標
    model_path : str
        保存された補正モデルのパス

    Returns:
    --------
    x_corrected, y_corrected : tuple of arrays
        補正後の座標
    """
    # モデルの読み込み
    rbf_x, rbf_y = load_correction_model(model_path)

    # 入力データの整形
    points = np.column_stack((x_original, y_original))

    # 補正量の計算
    correction_x = rbf_x(points)
    correction_y = rbf_y(points)

    # 補正の適用
    x_corrected = x_original + correction_x
    y_corrected = y_original + correction_y

    return x_corrected, y_corrected

# 使用例
if __name__ == "__main__":
    # サンプルデータ
    x_original = np.array([1.0, 1.5, 2.0, 2.5])
    y_original = np.array([1.0, 1.5, 2.0, 2.5])

    # モデルのパス
    model_path = "correction_model.pkl"

    # 補正の適用
    x_corrected, y_corrected = apply_correction_to_data(
        x_original, y_original, model_path
    )

    # 結果の表示
    for i in range(len(x_original)):
        print(f"Point {i+1}:")
        print(f"  Original: ({x_original[i]:.6f}, {y_original[i]:.6f})")
        print(f"  Corrected: ({x_corrected[i]:.6f}, {y_corrected[i]:.6f})")
        print(f"  Correction: ({x_corrected[i]-x_original[i]:.6f}, "
              f"{y_corrected[i]-y_original[i]:.6f})")
        print()
```

#### 4.3.3 再利用時の注意点
1. 座標系の一致確認
   - 補正モデル作成時と同じ座標系であることを確認
   - 単位の統一性を確認

2. データ範囲の確認
   - モデル作成時のデータ範囲内であることを確認
   - 外挿は避けることを推奨

3. エラー処理
   - ファイル読み込みエラー
   - データ形式の不一致
   - 範囲外データの処理

4. パフォーマンス考慮
   - 大量データの場合はバッチ処理を検討
   - メモリ使用量の監視

## 5. 他システムへの流用時の注意点

1. データ形式の互換性確保
   - 入力データフォーマットの統一
   - 座標系の整合性確認
   - 単位系の統一

2. パラメータ調整の必要性
   - 区画数の最適化
   - 補間方式の選択
   - 外周処理の調整

3. 性能に関する考慮
   - メモリ使用量の管理
   - 計算時間の最適化
   - スケーラビリティの確保

4. 実装時の留意点
   - エラー処理の実装
   - ログ機能の追加
   - テストケースの作成

## 6. 改善可能な点

1. アルゴリズムの最適化
   - 適応的な区画分割
   - マルチスレッド処理の導入
   - メモリ使用効率の向上

2. 機能の拡張
   - 異常値の自動検出
   - 信頼性指標の追加
   - バッチ処理対応

3. 使いやすさの向上
   - パラメータ自動最適化
   - GUIインターフェース
   - 結果の可視化強化
